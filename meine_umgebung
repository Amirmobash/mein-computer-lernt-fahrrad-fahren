## 0) Project folder (where you are)

Your project is here (like in your screenshot):

```bash
/home/amir/fahrrad_projekt
```

---

## 1) Full commands — from start to finish (English)

### A) System update + required tools

```bash
sudo apt update && sudo apt full-upgrade -y
sudo apt install -y python3-pip python3-venv python3-tk
```

### B) Create project + virtual environment

```bash
mkdir -p ~/fahrrad_projekt
cd ~/fahrrad_projekt

python3 -m venv meine_umgebung
source meine_umgebung/bin/activate

python -m pip install -U pip setuptools wheel
```

### C) Install Python packages (PINNED versions that work on Pi / Python 3.13)

> These pins avoid the old `flatbuffers ... import imp` problem.

```bash
pip install --no-cache-dir "protobuf>=5.28.0,<6" "flatbuffers>=24.3.25,<25"
pip install --no-cache-dir "tensorflow==2.20.0" "numpy" "pillow" "scipy"
```

### D) Quick sanity check (optional but recommended)

```bash
python3 -c "import tensorflow as tf, flatbuffers, google.protobuf, scipy; print('TF:', tf.__version__); print('flatbuffers:', flatbuffers.__version__); print('protobuf:', google.protobuf.__version__); print('scipy:', scipy.__version__)"
```

---

## 2) Dataset folders (exact structure)

```bash
cd ~/fahrrad_projekt
mkdir -p daten/train/bicycle daten/train/not_bicycle daten/test/bicycle daten/test/not_bicycle
ls -R daten
```

### What images go where?

* Put **bicycle images** into:

  * `daten/train/bicycle/`
  * `daten/test/bicycle/`
* Put **non-bicycle images** into:

  * `daten/train/not_bicycle/`
  * `daten/test/not_bicycle/`

### Do filenames matter?

No. Any names are fine (`abc.jpg`, `123.png`, `image_from_net.jpeg` …).
Just keep them as image files: **.jpg / .jpeg / .png**.

---

## 3) `fahrrad_lernen.py` (TRAINING SCRIPT) — full fixed code

Create the file:

```bash
nano fahrrad_lernen.py
```

Paste this **complete** code:

```python
import os
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# -----------------------------
# SETTINGS (Pi-friendly)
# -----------------------------
IMG_SIZE = (150, 150)
BATCH_SIZE = 16
EPOCHS = 5

TRAIN_DIR = "daten/train"
TEST_DIR = "daten/test"

MODEL_OUT_H5 = "mein_fahrrad_modell.h5"
MODEL_OUT_KERAS = "mein_fahrrad_modell.keras"  # modern format


def count_images(folder: str) -> int:
    count = 0
    for root, _, files in os.walk(folder):
        for f in files:
            if f.lower().endswith((".jpg", ".jpeg", ".png")):
                count += 1
    return count


print("\n=== DATA CHECK ===")
print(f"Train folder: {TRAIN_DIR}  -> images: {count_images(TRAIN_DIR)}")
print(f"Test folder : {TEST_DIR}   -> images: {count_images(TEST_DIR)}")
print()

# -----------------------------
# 1) DATA: generators
# -----------------------------
train_datagen = ImageDataGenerator(
    rescale=1.0 / 255.0,
    rotation_range=10,
    width_shift_range=0.05,
    height_shift_range=0.05,
    zoom_range=0.10,
    horizontal_flip=True
)

test_datagen = ImageDataGenerator(rescale=1.0 / 255.0)

train_generator = train_datagen.flow_from_directory(
    TRAIN_DIR,
    target_size=IMG_SIZE,
    batch_size=BATCH_SIZE,
    class_mode="binary",
    color_mode="rgb",
    shuffle=True
)

test_generator = test_datagen.flow_from_directory(
    TEST_DIR,
    target_size=IMG_SIZE,
    batch_size=BATCH_SIZE,
    class_mode="binary",
    color_mode="rgb",
    shuffle=False
)

print("\n=== CLASS INDICES ===")
print(train_generator.class_indices)

# steps: at least 1
steps_per_epoch = max(1, train_generator.samples // BATCH_SIZE)
validation_steps = max(1, test_generator.samples // BATCH_SIZE)

# -----------------------------
# 2) MODEL: small CNN
# -----------------------------
model = models.Sequential([
    layers.Input(shape=(IMG_SIZE[0], IMG_SIZE[1], 3)),

    layers.Conv2D(32, (3, 3), activation="relu"),
    layers.MaxPooling2D(2, 2),

    layers.Conv2D(64, (3, 3), activation="relu"),
    layers.MaxPooling2D(2, 2),

    layers.Conv2D(128, (3, 3), activation="relu"),
    layers.MaxPooling2D(2, 2),

    layers.Flatten(),
    layers.Dense(256, activation="relu"),
    layers.Dense(1, activation="sigmoid")  # probability
])

model.compile(
    optimizer="adam",
    loss="binary_crossentropy",
    metrics=["accuracy"]
)

print("\n=== Training starts now! ===")
print("Be patient: Raspberry Pi may be slower than a big PC.\n")

# -----------------------------
# 3) TRAIN
# -----------------------------
history = model.fit(
    train_generator,
    steps_per_epoch=steps_per_epoch,
    epochs=EPOCHS,
    validation_data=test_generator,
    validation_steps=validation_steps
)

# -----------------------------
# 4) SAVE
# -----------------------------
model.save(MODEL_OUT_H5)
model.save(MODEL_OUT_KERAS)

print(f"\n=== Done! Saved as '{MODEL_OUT_H5}' and '{MODEL_OUT_KERAS}' ===")
```

Save & exit nano:

* **CTRL + O** (write)
* **Enter**
* **CTRL + X** (exit)

Run training:

```bash
python3 fahrrad_lernen.py
```

After it finishes, you should see:

* `mein_fahrrad_modell.h5`
* `mein_fahrrad_modell.keras`

---

## 4) How the model “detects” bicycle vs not-bicycle (simple explanation)

* During training, images are resized to **150×150** and pixel values scaled to **0..1**.
* The CNN learns patterns using **convolutions**:

  * early layers learn edges/shapes,
  * deeper layers learn parts like wheels/frame,
  * finally it outputs **one number** with `sigmoid`:

    * near **0.0** = bicycle
    * near **1.0** = not_bicycle
* We choose a threshold (e.g. 0.5) to decide the label.

---

## 5) `testen.py` (GUI) — drag picture into a box + shows result (English)

### A) Optional: enable drag & drop

If you want real drag&drop support, install this:

```bash
pip install --no-cache-dir tkinterdnd2
```

### B) Create `testen.py`

```bash
nano testen.py
```

Paste this **complete** code:

```python
import os
import sys
import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk

import numpy as np
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image as keras_image

MODEL_PATH = "mein_fahrrad_modell.h5"
IMG_SIZE = (150, 150)

# If installed, we enable real drag & drop:
DND_AVAILABLE = False
try:
    from tkinterdnd2 import DND_FILES, TkinterDnD
    DND_AVAILABLE = True
except Exception:
    DND_AVAILABLE = False


def predict_image(model, img_path: str):
    # Load & preprocess like training
    img = keras_image.load_img(img_path, target_size=IMG_SIZE)
    arr = keras_image.img_to_array(img) / 255.0
    arr = np.expand_dims(arr, axis=0)

    pred = model.predict(arr, verbose=0)[0][0]  # sigmoid output
    # IMPORTANT: class_indices in your training were {'bicycle': 0, 'not_bicycle': 1}
    # So pred close to 0 => bicycle, close to 1 => not_bicycle
    prob_not_bicycle = float(pred)
    prob_bicycle = 1.0 - prob_not_bicycle

    if prob_bicycle >= prob_not_bicycle:
        label = "BICYCLE"
        confidence = prob_bicycle
    else:
        label = "NOT BICYCLE"
        confidence = prob_not_bicycle

    return label, confidence, prob_bicycle, prob_not_bicycle


class AppBase:
    def __init__(self, root):
        self.root = root
        self.root.title("Bicycle Detector (Raspberry Pi)")
        self.root.geometry("720x520")

        # Load model (compile=False removes the compiled-metrics warning)
        if not os.path.exists(MODEL_PATH):
            messagebox.showerror(
                "Model not found",
                f"Cannot find '{MODEL_PATH}'.\nRun training first:\npython3 fahrrad_lernen.py"
            )
            root.destroy()
            return

        self.model = load_model(MODEL_PATH, compile=False)

        self.header = tk.Label(root, text="Bicycle Detector", font=("Arial", 18, "bold"))
        self.header.pack(pady=10)

        self.sub = tk.Label(
            root,
            text="Select an image (or drag & drop if enabled).",
            font=("Arial", 11)
        )
        self.sub.pack()

        # Image preview box
        self.preview_frame = tk.Frame(root, bd=2, relief="groove")
        self.preview_frame.pack(pady=12)

        self.preview_label = tk.Label(self.preview_frame, text="No image yet", width=60, height=15)
        self.preview_label.pack(padx=10, pady=10)

        # Buttons
        self.btn_frame = tk.Frame(root)
        self.btn_frame.pack(pady=8)

        self.open_btn = tk.Button(self.btn_frame, text="Open Image...", command=self.open_image)
        self.open_btn.grid(row=0, column=0, padx=6)

        self.clear_btn = tk.Button(self.btn_frame, text="Clear", command=self.clear)
        self.clear_btn.grid(row=0, column=1, padx=6)

        # Result area
        self.result_label = tk.Label(root, text="Result: -", font=("Arial", 14))
        self.result_label.pack(pady=8)

        self.prob_label = tk.Label(root, text="", font=("Arial", 11))
        self.prob_label.pack()

        # Simple “confidence bar”
        self.canvas = tk.Canvas(root, width=520, height=26)
        self.canvas.pack(pady=8)
        self.canvas.create_rectangle(10, 8, 510, 20)  # border
        self.bar = self.canvas.create_rectangle(10, 8, 10, 20, fill="green")
        self.bar_text = self.canvas.create_text(260, 14, text="Confidence: 0%")

        self.tk_img = None  # keep reference

    def clear(self):
        self.preview_label.configure(image="", text="No image yet")
        self.tk_img = None
        self.result_label.configure(text="Result: -")
        self.prob_label.configure(text="")
        self.canvas.coords(self.bar, 10, 8, 10, 20)
        self.canvas.itemconfig(self.bar_text, text="Confidence: 0%")

    def open_image(self):
        path = filedialog.askopenfilename(
            title="Choose an image",
            filetypes=[("Images", "*.jpg *.jpeg *.png")]
        )
        if path:
            self.load_and_predict(path)

    def load_and_predict(self, path: str):
        if not os.path.exists(path):
            messagebox.showerror("File error", "File does not exist.")
            return

        # Show preview
        try:
            img = Image.open(path).convert("RGB")
            img_preview = img.copy()
            img_preview.thumbnail((520, 300))
            self.tk_img = ImageTk.PhotoImage(img_preview)
            self.preview_label.configure(image=self.tk_img, text="")
        except Exception as e:
            messagebox.showerror("Image error", f"Cannot open image:\n{e}")
            return

        # Predict
        try:
            label, conf, p_bike, p_not = predict_image(self.model, path)
        except Exception as e:
            messagebox.showerror("Prediction error", f"Prediction failed:\n{e}")
            return

        self.result_label.configure(text=f"Result: {label}")
        self.prob_label.configure(
            text=f"bicycle: {p_bike:.3f}   |   not_bicycle: {p_not:.3f}"
        )

        # Update confidence bar
        conf_pct = int(round(conf * 100))
        x0 = 10
        x1 = 10 + int(500 * (conf / 1.0))
        self.canvas.coords(self.bar, x0, 8, x1, 20)
        self.canvas.itemconfig(self.bar_text, text=f"Confidence: {conf_pct}%")

        # Color based on label
        if label == "BICYCLE":
            self.canvas.itemconfig(self.bar, fill="green")
        else:
            self.canvas.itemconfig(self.bar, fill="red")


def run_gui():
    if DND_AVAILABLE:
        root = TkinterDnD.Tk()
        app = AppBase(root)

        # Enable drop onto preview frame/label
        def drop(event):
            # event.data can contain braces and multiple files
            data = event.data.strip()
            # handle {file path}
            if data.startswith("{") and data.endswith("}"):
                data = data[1:-1]
            # if multiple files, take first
            if " " in data and os.path.exists(data.split(" ")[0]):
                data = data.split(" ")[0]
            app.load_and_predict(data)

        app.preview_label.drop_target_register(DND_FILES)
        app.preview_label.dnd_bind("<<Drop>>", drop)

        app.sub.configure(text="Select an image or drag & drop into the box.")
        root.mainloop()
    else:
        root = tk.Tk()
        app = AppBase(root)
        app.sub.configure(
            text="Select an image. (Drag & drop: install tkinterdnd2 to enable)"
        )
        root.mainloop()


def run_cli(img_path: str):
    if not os.path.exists(MODEL_PATH):
        print(f"ERROR: model not found: {MODEL_PATH}")
        print("Run training first: python3 fahrrad_lernen.py")
        sys.exit(1)

    model = load_model(MODEL_PATH, compile=False)
    label, conf, p_bike, p_not = predict_image(model, img_path)

    print("=== Prediction ===")
    print("File:", img_path)
    print("Result:", label)
    print(f"Confidence: {conf:.3f}")
    print(f"bicycle: {p_bike:.3f} | not_bicycle: {p_not:.3f}")


if __name__ == "__main__":
    if len(sys.argv) >= 2:
        run_cli(sys.argv[1])
    else:
        run_gui()
```

---

## 6) Run the GUI test

From inside the venv:

```bash
cd ~/fahrrad_projekt
source meine_umgebung/bin/activate
python3 testen.py
```

### CLI mode (optional)

```bash
python3 testen.py daten/test/bicycle/your_image.jpg
```

---

## 7) What files to push to GitHub

Inside `~/fahrrad_projekt`:

* ✅ `fahrrad_lernen.py`
* ✅ `testen.py`
* ✅ (optional) `README.md`
* ✅ (optional) `requirements.txt` (I can generate it if you want)
* ❌ `meine_umgebung/` (do not push venv)
* ❌ `daten/` (usually don’t push dataset)
* ❌ `mein_fahrrad_modell.h5` (optional — model file is big; you can ignore or upload via releases)
